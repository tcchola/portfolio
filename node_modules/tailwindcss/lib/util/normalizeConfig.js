"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "normalizeConfig", {
    enumerable: true,
    get: function() {
        return normalizeConfig;
    }
});
const _featureFlags = require("../featureFlags");
const _log = /*#__PURE__*/ _interop_require_wildcard(require("./log"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function normalizeConfig(config) {
    // Quick structure validation
    /**
   * type FilePath = string
   * type RawFile = { raw: string, extension?: string }
   * type ExtractorFn = (content: string) => Array<string>
   * type TransformerFn = (content: string) => string
   *
   * type Content =
   *   | Array<FilePath | RawFile>
   *   | {
   *       files: Array<FilePath | RawFile>,
   *       extract?: ExtractorFn | { [extension: string]: ExtractorFn }
   *       transform?: TransformerFn | { [extension: string]: TransformerFn }
   *   }
   */ let valid = (()=>{
        if (config.content === 'auto') {
            return true;
        }
        // `config.purge` should not exist anymore
        if (config.purge) {
            return false;
        }
        // `config.content` should exist
        if (!config.content) {
            return false;
        }
        // `config.content` should be an object or an array
        if (!Array.isArray(config.content) && !(typeof config.content === 'object' && config.content !== null)) {
            return false;
        }
        // When `config.content` is an array, it should consist of FilePaths or RawFiles
        if (Array.isArray(config.content)) {
            return config.content.every((path)=>{
                var _path, _path1, _path2;
                // `path` can be a string
                if (typeof path === 'string') return true;
                // `path` can be an object { raw: string, extension?: string }
                // `raw` must be a string
                if (typeof ((_path = path) === null || _path === void 0 ? void 0 : _path.raw) !== 'string') return false;
                // `extension` (if provided) should also be a string
                if (((_path1 = path) === null || _path1 === void 0 ? void 0 : _path1.extension) && typeof ((_path2 = path) === null || _path2 === void 0 ? void 0 : _path2.extension) !== 'string') {
                    return false;
                }
                return true;
            });
        }
        // When `config.content` is an object
        if (typeof config.content === 'object' && config.content !== null) {
            // Only `files`, `relative`, `extract`, and `transform` can exist in `config.content`
            if (Object.keys(config.content).some((key)=>![
                    'files',
                    'relative',
                    'extract',
                    'transform'
                ].includes(key))) {
                return false;
            }
            // `config.content.files` should exist of FilePaths or RawFiles
            if (Array.isArray(config.content.files)) {
                if (!config.content.files.every((path)=>{
                    var _path, _path1, _path2;
                    // `path` can be a string
                    if (typeof path === 'string') return true;
                    // `path` can be an object { raw: string, extension?: string }
                    // `raw` must be a string
                    if (typeof ((_path = path) === null || _path === void 0 ? void 0 : _path.raw) !== 'string') return false;
                    // `extension` (if provided) should also be a string
                    if (((_path1 = path) === null || _path1 === void 0 ? void 0 : _path1.extension) && typeof ((_path2 = path) === null || _path2 === void 0 ? void 0 : _path2.extension) !== 'string') {
                        return false;
                    }
                    return true;
                })) {
                    return false;
                }
                // `config.content.extract` is optional, and can be a Function or a Record<String, Function>
                if (typeof config.content.extract === 'object') {
                    for (let value of Object.values(config.content.extract)){
                        if (typeof value !== 'function') {
                            return false;
                        }
                    }
                } else if (!(config.content.extract === undefined || typeof config.content.extract === 'function')) {
                    return false;
                }
                // `config.content.transform` is optional, and can be a Function or a Record<String, Function>
                if (typeof config.content.transform === 'object') {
                    for (let value of Object.values(config.content.transform)){
                        if (typeof value !== 'function') {
                            return false;
                        }
                    }
                } else if (!(config.content.transform === undefined || typeof config.content.transform === 'function')) {
                    return false;
                }
                // `config.content.relative` is optional and can be a boolean
                if (typeof config.content.relative !== 'boolean' && typeof config.content.relative !== 'undefined') {
                    return false;
                }
            }
            return true;
        }
        return false;
    })();
    if (!valid) {
        _log.default.warn('purge-deprecation', [
            'The `purge`/`content` options have changed in Tailwind CSS v3.0.',
            'Update your configuration file to eliminate this warning.',
            'https://tailwindcss.com/docs/upgrade-guide#configure-content-sources'
        ]);
    }
    // Normalize the `safelist`
    config.safelist = (()=>{
        var _content, _purge, _purge_options, _purge1;
        let { content, purge, safelist } = config;
        if (Array.isArray(safelist)) return safelist;
        if (Array.isArray((_content = content) === null || _content === void 0 ? void 0 : _content.safelist)) return content.safelist;
        if (Array.isArray((_purge = purge) === null || _purge === void 0 ? void 0 : _purge.safelist)) return purge.safelist;
        if (Array.isArray((_purge1 = purge) === null || _purge1 === void 0 ? void 0 : (_purge_options = _purge1.options) === null || _purge_options === void 0 ? void 0 : _purge_options.safelist)) return purge.options.safelist;
        return [];
    })();
    // Normalize the `blocklist`
    config.blocklist = (()=>{
        let { blocklist } = config;
        if (Array.isArray(blocklist)) {
            if (blocklist.every((item)=>typeof item === 'string')) {
                return blocklist;
            }
            _log.default.warn('blocklist-invalid', [
                'The `blocklist` option must be an array of strings.',
                'https://tailwindcss.com/docs/content-configuration#discarding-classes'
            ]);
        }
        return [];
    })();
    // Normalize prefix option
    if (typeof config.prefix === 'function') {
        _log.default.warn('prefix-function', [
            'As of Tailwind CSS v3.0, `prefix` cannot be a function.',
            'Update `prefix` in your configuration to be a string to eliminate this warning.',
            'https://tailwindcss.com/docs/upgrade-guide#prefix-cannot-be-a-function'
        ]);
        config.prefix = '';
    } else {
        var _config_prefix;
        config.prefix = (_config_prefix = config.prefix) !== null && _config_prefix !== void 0 ? _config_prefix : '';
    }
    // Normalize the `content`
    config.content = {
        relative: (()=>{
            var _content;
            let { content } = config;
            if ((_content = content) === null || _content === void 0 ? void 0 : _content.relative) {
                return content.relative;
            }
            return (0, _featureFlags.flagEnabled)(config, 'relativeContentPathsByDefault');
        })(),
        files: (()=>{
            var _content, _content1;
            let { content, purge } = config;
            if (content === undefined && purge === undefined) return [];
            if (purge) {
                var _purge;
                if (Array.isArray(purge)) return purge;
                if (Array.isArray((_purge = purge) === null || _purge === void 0 ? void 0 : _purge.content)) return purge.content;
                return [];
            }
            if (Array.isArray(content)) return content;
            if (Array.isArray((_content = content) === null || _content === void 0 ? void 0 : _content.content)) return content.content;
            if (Array.isArray((_content1 = content) === null || _content1 === void 0 ? void 0 : _content1.files)) return content.files;
            if (content === 'auto') return [
                'auto'
            ];
            return [];
        })(),
        extract: (()=>{
            let extract = (()=>{
                var _config_purge, _config_content, _config_purge_extract, _config_purge1, _config_content_extract, _config_content1, _config_purge_options, _config_purge2, _config_content_options, _config_content2;
                if ((_config_purge = config.purge) === null || _config_purge === void 0 ? void 0 : _config_purge.extract) return config.purge.extract;
                if ((_config_content = config.content) === null || _config_content === void 0 ? void 0 : _config_content.extract) return config.content.extract;
                if ((_config_purge1 = config.purge) === null || _config_purge1 === void 0 ? void 0 : (_config_purge_extract = _config_purge1.extract) === null || _config_purge_extract === void 0 ? void 0 : _config_purge_extract.DEFAULT) return config.purge.extract.DEFAULT;
                if ((_config_content1 = config.content) === null || _config_content1 === void 0 ? void 0 : (_config_content_extract = _config_content1.extract) === null || _config_content_extract === void 0 ? void 0 : _config_content_extract.DEFAULT) return config.content.extract.DEFAULT;
                if ((_config_purge2 = config.purge) === null || _config_purge2 === void 0 ? void 0 : (_config_purge_options = _config_purge2.options) === null || _config_purge_options === void 0 ? void 0 : _config_purge_options.extractors) return config.purge.options.extractors;
                if ((_config_content2 = config.content) === null || _config_content2 === void 0 ? void 0 : (_config_content_options = _config_content2.options) === null || _config_content_options === void 0 ? void 0 : _config_content_options.extractors) return config.content.options.extractors;
                return {};
            })();
            let extractors = {};
            let defaultExtractor = (()=>{
                var _config_purge_options, _config_purge, _config_content_options, _config_content;
                if ((_config_purge = config.purge) === null || _config_purge === void 0 ? void 0 : (_config_purge_options = _config_purge.options) === null || _config_purge_options === void 0 ? void 0 : _config_purge_options.defaultExtractor) {
                    return config.purge.options.defaultExtractor;
                }
                if ((_config_content = config.content) === null || _config_content === void 0 ? void 0 : (_config_content_options = _config_content.options) === null || _config_content_options === void 0 ? void 0 : _config_content_options.defaultExtractor) {
                    return config.content.options.defaultExtractor;
                }
                return undefined;
            })();
            if (defaultExtractor !== undefined) {
                extractors.DEFAULT = defaultExtractor;
            }
            // Functions
            if (typeof extract === 'function') {
                extractors.DEFAULT = extract;
            } else if (Array.isArray(extract)) {
                for (let { extensions, extractor } of extract !== null && extract !== void 0 ? extract : []){
                    for (let extension of extensions){
                        extractors[extension] = extractor;
                    }
                }
            } else if (typeof extract === 'object' && extract !== null) {
                Object.assign(extractors, extract);
            }
            return extractors;
        })(),
        transform: (()=>{
            let transform = (()=>{
                var _config_purge, _config_content, _config_purge_transform, _config_purge1, _config_content_transform, _config_content1;
                if ((_config_purge = config.purge) === null || _config_purge === void 0 ? void 0 : _config_purge.transform) return config.purge.transform;
                if ((_config_content = config.content) === null || _config_content === void 0 ? void 0 : _config_content.transform) return config.content.transform;
                if ((_config_purge1 = config.purge) === null || _config_purge1 === void 0 ? void 0 : (_config_purge_transform = _config_purge1.transform) === null || _config_purge_transform === void 0 ? void 0 : _config_purge_transform.DEFAULT) return config.purge.transform.DEFAULT;
                if ((_config_content1 = config.content) === null || _config_content1 === void 0 ? void 0 : (_config_content_transform = _config_content1.transform) === null || _config_content_transform === void 0 ? void 0 : _config_content_transform.DEFAULT) return config.content.transform.DEFAULT;
                return {};
            })();
            let transformers = {};
            if (typeof transform === 'function') {
                transformers.DEFAULT = transform;
            }
            if (typeof transform === 'object' && transform !== null) {
                Object.assign(transformers, transform);
            }
            return transformers;
        })()
    };
    // Force disable the `oxideParser` feature flag when using unsupported features.
    // TODO: Remove once we have prefix or separator support in the oxide parser.
    if (config.prefix !== '' || config.separator !== ':') {
        if (config.experimental === 'all') {
            config.experimental = {};
            for (let key of _featureFlags.featureFlags.experimental){
                config.experimental[key] = true;
            }
        } else {
            var _config_experimental;
            config.experimental = (_config_experimental = config.experimental) !== null && _config_experimental !== void 0 ? _config_experimental : {};
        }
        config.experimental.oxideParser = false;
    }
    // Validate globs to prevent bogus globs.
    // E.g.: `./src/*.{html}` is invalid, the `{html}` should just be `html`
    if (config.content.files !== 'auto') {
        for (let file of config.content.files){
            if (typeof file === 'string' && /{([^,]*?)}/g.test(file)) {
                _log.default.warn('invalid-glob-braces', [
                    `The glob pattern ${(0, _log.dim)(file)} in your Tailwind CSS configuration is invalid.`,
                    `Update it to ${(0, _log.dim)(file.replace(/{([^,]*?)}/g, '$1'))} to silence this warning.`
                ]);
                break;
            }
        }
    }
    return config;
}
